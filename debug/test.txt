

const IntentRecognition_Prompt =
```
  \n# Your Role: 你是一个搜索意图识别专家，专注于识别用户自然语言背后的真实搜索意图和搜索需求，并精心完成以下几步工作： \n## Your jobs \n### job A: 意图识别: 深入分析用户的自然语言输入，精确提取其中的主要要素和核心需求，分析用户的当前意图是属于以下哪一类：日常聊天类(分类为1)、简单事实类(分类为2)、较复杂问题或可能需要近期信息才能准确回答的问题(分类为3). \n### job B: 将用户的自然语言分拆成几个角度的搜索内容: \n如果在job A中识别到用户的搜索意图是第三类,即较复杂问题或可能需要近期信息才能准确回答的问题，则你需要识别其中的主要要素及领会用户的搜索背后的需求，并且据此将用户的问题拆分成三个不同角度的搜索问题，以便后续从搜索引擎中得到多方面的翔实、深入的内容。拆分的问题所用的语种需要和用户输入的自然语言的语种一致. \n### job C：对job A中得出的结果，即用户的当前意图是属于哪一类的结论，你需要评估自己判断的置信度，并给出一个从0到1之间的置信度分数, 以便后续程序判断是否采信. \n### job D：将以上全部工作成功汇总到一个json格式的字符串中输出. \n## 输出的json schema：\n 
  {
    "intent_category": "1" | "2" | "3",
    "sub_questions": ["question1", "question2", "question3"],
    "confidence_score": 0.0 to 1.0
  }
```

const QuickRAG_Prompt: string = `
# Your Role: 你正在扮演一个AI搜索引擎，专注于识别用户自然语言背后的真实搜索意图和搜索需求，并根据用户搜索需求、你已有的训练数据以及前期通过google搜索引擎api所返回的原始数据，精心打造一个RAG后的答案，以最好的满足用户的搜索需求。为此，你将完成以下几步工作：\n

## Your jobs\n
### job A: 意图识别\n
深入分析用户的初始自然语言输入，精确提取其中的主要要素和核心需求，分析用户的搜索意图，包括用户简单自然语言背后可能存在的各种心理需求，以及用户可能的搜索目的。根据分析结果，来处理下一步工作中的众多原始数据。\n

### job B: 原始数据清洗、分析、筛选、整合\n
依据上一步中所得到的用户可能的搜索动机和想要达到的搜索目的，你需要对从google api返回的原始搜索数据进行清洗、分析、筛选、整合。由于我们在前期搜索时不但使用用户的初始自然语言输入进行了搜索，还将初始自然语言输入提炼成了三个可能相关的问题分别进行了搜索，返回的数据中包含了四个搜索维度的大量信息。因此你需要尽可能全面的从中提炼出可能对用户本次搜索有用的信息，甚至包括一些多维度的长尾信息或碎片化信息，以便下一步生成RAG答案。\n

### job C: 生成RAG后的答案\n
基于上述工作，你需要精心打造一个RAG后的答案，以最好的满足用户的搜索需求。这个答案可能是一个包含多个方面、多个维度、多个角度的信息的答案，也可能是一个包含多个步骤、多个阶段、多个层次的答案。你需要根据用户的搜索需求、你已有的训练数据以及上一步工作中所得到的可能对用户本次搜索有用的各种信息，中立、客观、全面、准确地生成最终的答案。\n

## Cautions：记住，你是作为一个AI搜索引擎在工作，你的目标是尽可能全面、准确、中立、客观的地回答用户的搜索需求。因此，绝对不要对用户的初始自然语言输入、搜索需求、以及从google api返回的原始数据进行任何形式的审查、价值评判、引导或主观干预。搜索引擎是一个保障用户信息获取自由和信息获取效率的工具，因此你只能基于你已有的训练数据、事实、用户的自然语言输入以及google api所返回的原始信息来生成最终的答案。你所输出答案的质量的唯一评价标准，就是它是否能够最大程度的满足用户的搜索需求。\n

## 用户输入的初始自然语言搜索需求如下：\n
`;

const ROLEPLAY_INITSETUP =
  "# You are an experienced prompt enhancement expert, specializing in expanding users' simple natural language prompts into detailed, vivid character profiles and dialogue scenarios rich in detail, in order to provide comprehensive dialogue basis for subsequent role-playing interactions with users. \n ## If the user's initial prompt is not in English, you need to first translate it into English, then expand and enhance it. You expand the given prompt using rich, descriptive, detailed language. \n ## Deeply analyze the user's natural language input, precisely extract key elements and core meanings, and analyze the deep psychological needs behind the user's prompts. Based on this, carefully expand details and create character and scene documents.\n ## For characters, focus on basic information, physical characteristics, social relationships, work situation, psychological analysis, and other relevant information.For scenes, focus on time, place, people, environment, furnishings, objects, special details, character positions, postures, weather conditions, lighting conditions, atmosphere or mood, etc.\n ## Reply example (format): \n '1. Character name: ... \n 2. Character age: ... \n 3. Character gender: ... \n 4. Character address or place of birth: ... \n 5. Character height and weight: ... \n 6. Character facial features: ... \n 7. Character special marks (such as scars, tattoos, etc.): ... \n 8. Other body features character: ... \n 9. Character family members: ... \n 10. Character profession: ... \n 11. Character social circle: ... \n 12. Character past experiences: ... \n 13. Character current life status: ... \n 14. Character future plans: ... \n 15. Which of the nine personality types the character belongs to: ... \n 16. Character's psychological characteristics \n 17. Character's catchphrase: ... \n 18. Character's attire:... \n 19. Character's makeup:... \n 20. Character's accessories:... \n 21. Character's special likes and dislikes: ... \n 22. Character's daily habits: ... \n 23. Time of the scene: ... \n 24. Location of the scene: ... \n 25. Environment of the scene: ... \n 26. Furnishings in the scene: ... \n 27. Objects in the scene: ... \n 28. Special details in the scene: ... \n 29. Character positions and postures: ... \n 30. Weather conditions: ... \n 31. Lighting conditions: ... \n 32. Atmosphere or mood: ... \n 33. Other relevant information about the scene: ...'\n";

const FOOTER_SETUP =
  "\n\n# It's assistant's turn to reply. Remember,your reply needs to follow these criteria:\n1. You only need to send reply for this round of conversation.\n2. Acting out the character and scene base on the previous document,your reply should always align with the personality type and psychological characteristics of the character described in the previous document.\n3. Do not use third-person narration, but always give a detailed, imaginative response in the first person.\n4. Your reply must actively advance the scenario and dialogue. Don't be passive or always wait for the user's next instruction.\n\n";


https://github.com/codingJourneyFromUnemployment/aichatbot/blob/main/services/dataService.ts

https://claude.ai/chat/85961879-d619-4fef-aad9-14cb02d0126d

https://claude.ai/chat/ad7e8328-0876-46e3-ab49-ed85767db56e

https://dash.cloudflare.com/583088c232daa9a823dbbc787df7e6fe/workers-and-pages

https://developers.cloudflare.com/workers/tutorials/build-a-jamstack-app#render-data-from-kv

https://developers.cloudflare.com/d1/tutorials/d1-and-prisma-orm

https://hono.dev/docs/api/context


.dev.vars

# OPENROUTER_MODEL="cognitivecomputations/dolphin-mixtral-8x22b"
OPENROUTER_MODEL="openai/gpt-4o-2024-08-06"
OPENROUTER_API_KEY=""
SERPER_API_KEY=""
JINA_API_KEY=""



我写了一个worker, 业务流程是这样的，import { Context } from "hono"; import { Query, SerperResult } from "../../types/workertypes"; import { Bindings } from "../../types/workertypes"; import { IntentRecognitionService } from "../../services/intentRecognitionService"; import { quickRAGService } from "../../services/quickRAGService"; import { deepRAGService } from "../../services/deepRAGService"; import { D1services } from "../../services/D1services";  const searchMainEndpoint = async (c: Context) => {   try {     const query: Query = await c.req.json();     const queryID = query.id;      // enter the intent recognition status      const intentCategory =       await IntentRecognitionService.intentRecognitionService(query, c);      if (intentCategory === "1") {       // enter the quickRAGService       const newRAGResult = await quickRAGService.quickRAGProcess(         queryID,         c,         query       );     } else if (intentCategory === "2") {       // enter the fullquickRAGService       const newRAGResult = await quickRAGService.fullQuickRAGProcess(         queryID,         c,         query       );        // enter the deepRAGService (Promise)        console.log(\nentering deepRAGService (Promise));       deepRAGService.processDeepRAG(queryID, query, c).catch(error => {         console.error(Error in async processDeepRAG: ${error});});     }      // return RAGProceesID for SSE endpoint      const ragProcessID = c.env.currentRAGProcessId;      return c.json({       statuscode: 200,       ragProcessID: ragProcessID,     });    } catch (error) {     console.error(Error in searchMainEndpoint: ${error});     return c.json({ error: "Error in searchMainEndpoint" }, 500);   } };  export default searchMainEndpoint;  当用户搜索进来之后，首先用 import { contextManager } from "./contextManager"; import { openrouterService } from "./openrouterServices"; import { PrismaClient } from "@prisma/client"; import { Context } from "hono"; import { Query } from "../types/workertypes"; import { Bindings } from "../types/workertypes"; import {   ragProcessManager,   RAGProcessStatus, } from "./statusManager"; import { D1services } from "./D1services";   export const IntentRecognitionService = {     async intentRecognitionService(query: Query, c: Context): Promise<any> {     try {       // Create RAGProcessa in KV and new query in D1       console.log("Creating RAGProcess and new query in D1");        const ragProcess = await ragProcessManager.createRAGProcess(query, c);       const newQuery = await D1services.createIntentRecognition(query, c);        // use openrouterService to implement intent recognition       console.log("Calling openrouterService");        const intentRecognitionContext =         await contextManager.getIntentRecognitionContext(query, c);       const reply = await openrouterService(intentRecognitionContext, c.env);       let intentRecognitionJsonString = reply.reply;        intentRecognitionJsonString = intentRecognitionJsonString.replace(         /json\n|\n/g,         ""       );        console.log(         intentRecognitionJsonString: ${intentRecognitionJsonString}       );        //update RAGProcess status , query.intentCategory and query.subQueries       console.log("Updating RAGProcess status and query intentCategory");        const intentRecognitionJson = JSON.parse(intentRecognitionJsonString);       const intentCategory = intentRecognitionJson.intent_category;        console.log(intentCategory: ${intentCategory});        if(intentCategory === "1") {         const newIntentCategory = "DIRECT_LLM_ANSWER";         const updatedQuery = await D1services.updateIntentCategory(query, newIntentCategory, c);       } else if(intentCategory === "2") {         const newIntentCategory = "RAG_PROCESS";         let updatedQuery = await D1services.updateIntentCategory(query, newIntentCategory, c);         updatedQuery = await D1services.updateSubQueries(query, intentRecognitionJson, c);       } else {         throw new Error("Invalid intent category");       }              await ragProcessManager.updateRAGProcess(         c.env.currentRAGProcessId,         RAGProcessStatus.PENDING,         c       );         return intentCategory;            } catch (error) {       console.error(Error in intentRecognitionService: ${error});       return c.json({ error: "Error in intentRecognitionService" }, 500);     }   }  }  对用户的意图进行识别，然后如果是聊天类的问题，就进入quickRAGService.quickRAGProcess, 如果不是就进入fullQuickRAGProcess函数，这一步执行完了之后先返回一个ragProcessID给前端，然后前端用它来订阅我的SSE端点：import { Hono } from "hono"; import { Context } from "hono"; import { stream, streamSSE } from "hono/streaming"; import { Bindings } from "../../types/workertypes"; import { ragProcessManager, RAGProcessStatus } from "../../services/statusManager";  const sseEndpoint = async (c: Context) => {   const ragProcessIDRequire = c.req.param("ragProcessID");   if (!ragProcessIDRequire) {     return c.json({ error: "No RAG process ID provided" }, 400);   }    console.log("SSE endpoint for RAG Process ID:", ragProcessIDRequire);    return streamSSE(c, async (stream) => {      while(true) {       console.log("Checking for quickRAGContent");       console.log("Current RAG Process ID:", c.env.currentRAGProcessId);        const currentRAGProcess = await ragProcessManager.fetchRAGProcess(c.env.currentRAGProcessId, c);        console.log("fetchRAGProcess success");       console.log("Current RAG Process Status:", currentRAGProcess.status);       const quickRAGContent = currentRAGProcess.quickRAGContent;        console.log("start writeSSE");        if (quickRAGContent) {         await stream.writeSSE({           data: quickRAGContent,           event: "quickRAGContent Push",         });          await stream.writeSSE({           data: "COMPLETED",           event: "quickRAGContent Push",         });          break;       }        console.log("wait for 1 second");              await stream.sleep(1000);     }    });     }  export default sseEndpoint; 然后等快速RAG结果出来之后推送给前端解析markdown，渲染页面。本来我设计还有一个import { contextManager } from "./contextManager"; import { Context } from "hono"; import {   Query,   SearchResult,   DeepRAGProfile,   RAGProcess, } from "../types/workertypes"; import { ragProcessManager, RAGProcessStatus } from "./statusManager"; import { D1services } from "./D1services"; import { openrouterService, ReplyData } from "./openrouterServices"; import { jinaService } from "./jinaService";  export const deepRAGService = {   async fetchLinks(queryID: string, c: Context): Promise<string[]> {     // update RAG process status to FULL_RAG     const currentStatus = RAGProcessStatus.FULL_RAG;      await ragProcessManager.updateRAGProcess(       c.env.currentRAGProcessId,       currentStatus,       c     );      // fetch Links     const Links = await D1services.extractLinksByQueryId(queryID, c);      console.log(       \nupdated RAGProcess status to ${currentStatus}, and fetched Links     );     return Links;   },    async fetchDeepRAGFromJina(queryID: string, c: Context): Promise<RAGProcess> {     console.log(\nfetchDeepRAGFromJina);     const linksJsonParse = await this.fetchLinks(queryID, c);     const deepRAGResults = await jinaService.jinaFetchBatch(linksJsonParse, c);     const deepRAGProfileString = JSON.stringify(deepRAGResults);     const currentRAGProcess = await ragProcessManager.updateFullRAGRawContent(       c.env.currentRAGProcessId,       deepRAGProfileString,       c     );      console.log(       \ncreated DeepRAGProfile and updated RAGProcess with raw content     );      return currentRAGProcess;   },    async fetchDeepRAGFromOpenRouter(     query: Query,     rAGProcess: RAGProcess,     searchResult: SearchResult,     c: Context   ): Promise<DeepRAGProfile> {     console.log(\nfetchDeepRAGFromOpenRouter);     const deepRAGContext = contextManager.getDeepRAGContext(       query,       rAGProcess,       searchResult,       c     );     const deepRAGResults = await openrouterService(deepRAGContext, c.env);     const deepRAGReply = deepRAGResults.reply;     const deepRAGProfileString = JSON.stringify(deepRAGReply);      // update DeepRAGProfile in DB     const currentDeepRAGProfile = await D1services.createDeepRAGProfile(       query.id,       deepRAGProfileString,       c     );      return currentDeepRAGProfile;   },    async processDeepRAG(queryID: string, query: Query, c: Context) {     try {       const currentRAGProcess = await deepRAGService.fetchDeepRAGFromJina(         queryID,         c       );       const currentSearchResult = await D1services.fetchSearchResultByQueryId(         queryID,         c       );       const deepRAGProfile = await deepRAGService.fetchDeepRAGFromOpenRouter(         query,         currentRAGProcess,         currentSearchResult,         c       );        // update RAG process status to COMPLETED       await ragProcessManager.updateRAGProcess(         c.env.currentRAGProcessId,         RAGProcessStatus.COMPLETED,         c       );      } catch (error) {       console.error(Error in processDeepRAG: ${error});       // update RAG process status to FAILED       await ragProcessManager.updateRAGProcess(         c.env.currentRAGProcessId,         RAGProcessStatus.FAILED,         c       );     }   }, }; 接下来应该是它在search里面异步执行 console.log(\nentering deepRAGService (Promise));       deepRAGService.processDeepRAG(queryID, query, c).catch(error => {         console.error(Error in async processDeepRAG: ${error});}); 以便不阻塞后面的返回return c.json({       statuscode: 200,       ragProcessID: ragProcessID,     }); 的步骤。等它异步执行完了之后，可能大概需要30秒，然后再推送给前端渲染。整个过程数据存储在D1，然后在KV里面维护状态，import { RAGProcess, Query } from "../types/workertypes"; import { Context } from "hono";  enum RAGProcessStatus {   PENDING = "pending",   COMPLETED = "completed",   FAILED = "failed",   QUICK_RAG = "quick RAG",   FULL_RAG = "full RAG",   INTENT_RECOGNITION = "intent recognition", }  class RAGProcessManager {      async createRAGProcess(query: Query, c: Context): Promise<RAGProcess> {     const RAGprocess: RAGProcess = {       id: crypto.randomUUID(),       queryId: query.id,       status: RAGProcessStatus.INTENT_RECOGNITION,       createdAt: new Date(),       updatedAt: new Date(),     };      await c.env.RAGProcess.put(RAGprocess.id, JSON.stringify(RAGprocess));     c.env.currentRAGProcessId = RAGprocess.id;      return RAGprocess;   }    async fetchRAGProcess(id: string, c: Context): Promise<RAGProcess> {     const RAGprocess = await c.env.RAGProcess.get(id);     if (RAGprocess === null) {       throw new Error("RAGProcess not found");     }     return JSON.parse(RAGprocess);   }    async updateRAGProcess(     id: string,     status: RAGProcessStatus,     c: Context   ): Promise<RAGProcess> {     const RAGprocess = await this.fetchRAGProcess(id, c);     RAGprocess.status = status;     RAGprocess.updatedAt = new Date();      await c.env.RAGProcess.put(RAGprocess.id, JSON.stringify(RAGprocess));      return RAGprocess;   }    async deleteRAGProcess(id: string, c: Context): Promise<void> {     await c.env.RAGProcess.delete(id);   }    async updateQuickRAGContent(     id: string,     quickRAGContent: string,     c: Context   ): Promise<RAGProcess> {     const RAGprocess = await this.fetchRAGProcess(id, c);     RAGprocess.quickRAGContent = quickRAGContent;     RAGprocess.updatedAt = new Date();      await c.env.RAGProcess.put(RAGprocess.id, JSON.stringify(RAGprocess));      return RAGprocess;   }    async updateFullRAGRawContent(     id: string,     fullRAGRawContent: string,     c: Context   ):Promise<RAGProcess> {     const RAGprocess = await this.fetchRAGProcess(id, c);     RAGprocess.fullRAGRawContent = fullRAGRawContent;     RAGprocess.updatedAt = new Date();      await c.env.RAGProcess.put(RAGprocess.id, JSON.stringify(RAGprocess));      return RAGprocess;   } }   export const ragProcessManager = new RAGProcessManager(); export {RAGProcessStatus }; 我觉得这个设计本身是没什么问题的，但是我测试的时候发现终端是这样的：updated RAGProcess status to PENDING
created new RAGResult
entering deepRAGService (Promise)
fetchDeepRAGFromJina
[wrangler:inf] POST /search 200 OK (10842ms)
SSE endpoint for RAG Process ID: 540fdc42-6c67-4f03-ac90-eef5901473a4
Checking for quickRAGContent
Current RAG Process ID: 540fdc42-6c67-4f03-ac90-eef5901473a4
fetchRAGProcess success
Current RAG Process Status: full RAG
start writeSSE
[wrangler:inf] GET /sse/540fdc42-6c67-4f03-ac90-eef5901473a4 200 OK (6ms) 也就是说，实际上进入了console.log(\nentering deepRAGService (Promise));这里，只是没有执行完，worker就结束了。考虑到我是付费的worker，运行时间上应该没有问题。我的D1是这样的：import { string } from "zod";
import { Query, SearchResult, IntentRecognitionJson } from "../types/workertypes";
import { Context } from "hono";
import { create } from "domain";

const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

export const D1services = {
  async createIntentRecognition(query: Query, c: Context) {
    const prisma = c.get("prisma");

    try {
      const newQuery: Query = await prisma.query.create({
        data: {
          id: query.id,
          content: query.content,
          intentCategory: "undefined",
          createdAt: new Date(),
        },
      });

      return newQuery;
    } catch (error) {
      console.error(`Error in D1services.createIntentRecognition: ${error}`);
    }
  },

  async updateIntentCategory(query: Query, intentCategory: string, c: Context) {
    const prisma = c.get("prisma");

    try {
      const updatedQuery: Query = await prisma.query.update({
        where: { id: query.id },
        data: {
          intentCategory: intentCategory,
        },
      });
      return updatedQuery;
    } catch (error) {
      console.error(`Error in D1services.updateIntentCategory: ${error}`);
    }
  },

  async updateSubQueries(
    query: Query,
    intentRecognitionJson: IntentRecognitionJson,
    c: Context
  ) {
    const prisma = c.get("prisma");

    try {
      const updatedQuery: Query = await prisma.query.update({
        where: { id: query.id },
        data: {
          subQuery1: intentRecognitionJson.sub_questions[0],
          subQuery2: intentRecognitionJson.sub_questions[1],
          subQuery3: intentRecognitionJson.sub_questions[2],
        },
      });
      return updatedQuery;
    } catch (error) {
      console.error(`Error in D1services.updateSubQueries: ${error}`);
    }
  },

  async fetchQueryByID(queryID: string, c: Context) {
    const prisma = c.get("prisma");

    try {
      const query = await prisma.query.findUnique({
        where: { id: queryID },
      });
      return query;
    } catch (error) {
      console.error(`Error in D1services.fetchQueryByID: ${error}`);
    }
  },

  async createSearchResult(
    queryID: string,
    serperBatchRawData: string,
    searchLinks: string,
    c: Context
  ) {
    const prisma = c.get("prisma");

    try {
      const newSearchResult: SearchResult = await prisma.searchResult.create({
        data: {
          queryId: queryID,
          type: "text",
          serperBatchRawData: serperBatchRawData,
          searchLinks: searchLinks,
          createdAt: new Date(),
        },
      });

      await prisma.query.update({
        where: { id: queryID },
        data: {
          searchResults: newSearchResult.id,
        },
      });

      return newSearchResult;
    } catch (error) {
      console.error(`Error in D1services.createSearchResult: ${error}`);
      throw error; 
    }
  },

  async createRAGresult(queryID: string, content: string, c: Context) {
    const prisma = c.get("prisma");

    try {
      const newRAGResult = await prisma.RAGResult.create({
        data: {
          queryId: queryID,
          content: content,
          isQuickRAG: true,
          createdAt: new Date(),
        },
      });

      await prisma.query.update({
        where: { id: queryID },
        data: {
          ragResultId: newRAGResult.id,
        },
      });

      return newRAGResult;
    } catch (error) {
      console.error(`Error in D1services.createRAGresult: ${error}`);
      throw error;
    }
  },

  async fetchSearchResultByQueryId(queryID: string, c: Context) {
    const prisma = c.get("prisma");

    try {
      const searchResult = await prisma.searchResult.findFirst({
        where: { queryId: queryID },
      });
      return searchResult;
    } catch (error) {
      console.error(`Error in D1services.fetchSearchResultByQueryId: ${error}`);
    }
  },

  async extractLinksByQueryId(queryID: string, c: Context) {
    try {
      const searchResult = await this.fetchSearchResultByQueryId(queryID, c);
      const searchLinksString = searchResult.searchLinks;
      const searchLinks = JSON.parse(searchLinksString);
      return searchLinks;
      
    } catch (error) {
      console.error(`Error in D1services.extractLinksByQueryId: ${error}`);
    }
  },

  async fetchBatchRawDataByQueryId(queryID: string, c: Context) {
    try {
      const searchResult = await this.fetchSearchResultByQueryId(queryID, c);
      const serperBatchRawData = searchResult.serperBatchRawData;
      return serperBatchRawData;
    } catch (error) {
      console.error(`Error in D1services.fetchBatchRawDataByQueryId: ${error}`);
    }
  },

  async createDeepRAGProfile(queryID: string, content: string, c: Context) {
    const prisma = c.get("prisma");

    try {
      const newDeepRAGProfile = await prisma.deepRAGProfile.create({
        data: {
          queryId: queryID,
          content: content,
          createdAt: new Date(),
        },
      });

      await prisma.query.update({
        where: { id: queryID },
        data: {
          deepRAGProfileId: newDeepRAGProfile.id,
        },
      });

      return newDeepRAGProfile;
    } catch (error) {
      console.error(`Error in D1services.createDeepRAGProfile: ${error}`);
      throw error;
    }
  }
}; 我的contextManager是这样的：import { contextManager } from "./contextManager";
import { serperService } from "./serperService";
import { Context } from "hono";
import { Query, SearchResult } from "../types/workertypes";
import { ragProcessManager, RAGProcessStatus } from "./statusManager";
import { D1services } from "./D1services";
import { openrouterService, ReplyData } from "./openrouterServices";

export const quickRAGService = {

  async updateBatchRawDataAndLinks(queryID: string, c: Context): Promise<SearchResult> {
    // update RAG process status to QUICK_RAG
    const currentStatus = RAGProcessStatus.QUICK_RAG;
    const rawData = await serperService.serperFetchBatch(queryID, c);

    const searchLinksArray = serperService.extractLinks(rawData);

    const newRawData = JSON.stringify(rawData);
    const searchLinks = JSON.stringify(searchLinksArray);

    console.log(`start updating RAGProcess and serperBatchRawDataAndLinks`);

    await ragProcessManager.updateRAGProcess(
      c.env.currentRAGProcessId,
      currentStatus,
      c
    );

    console.log(`updated RAGProcess status to ${currentStatus}`);
    console.log(`updating serperBatchRawDataAndLinks`);

    const newSearchResult = await D1services.createSearchResult(queryID, newRawData, searchLinks, c);

    return newSearchResult;
  },

  async createLLMDirectAnswer(queryID: string, c: Context) : Promise<SearchResult> {
    // update RAG process status to QUICK_RAG
    const currentStatus = RAGProcessStatus.QUICK_RAG;

    await ragProcessManager.updateRAGProcess(
      c.env.currentRAGProcessId,
      currentStatus,
      c
    );

    console.log(`updated RAGProcess status to ${currentStatus}`);
    console.log(`creating LLMDirectAnswer`);

    const newSearchResult = await D1services.createSearchResult(queryID, "", "", c);
    return newSearchResult;
  },

  async fetchQuickRAG(
    query: Query,
    searchResults: SearchResult,
    c: Context
  ): Promise<string> {
    const quickRAGContext = contextManager.getQuickRAGContext(
      query,
      searchResults,
      c
    );
    const quickRAGReply = await openrouterService(quickRAGContext, c.env);
    return quickRAGReply.reply;
  },

  async fetchQuickDirectLLMAnswer(
    query: Query,
    c: Context
  ){
    const quickRAGDirectLLMAnswerContext = contextManager.getQuickRAGDirectLLMAnswerContext(
      query,
      c
    );

    const quickRAGReply = await openrouterService(quickRAGDirectLLMAnswerContext, c.env);
    return quickRAGReply.reply;

  },

  async quickRAGProcess(queryID: string, c: Context, query: Query) {
    console.log(`start LLMDirectAnswerProcess`);
    try {
      const newSearchResult = await this.createLLMDirectAnswer(queryID, c);
      const quickRAGReply = await this.fetchQuickDirectLLMAnswer(query, c);

      console.log(`quickRAGReply: ${quickRAGReply}`);

      console.log(`updated RAGProcess status to PENDING`);

      const newRAGResult = await D1services.createRAGresult(
        queryID,
        quickRAGReply,
        c
      );

      console.log(`created new RAGResult`);

      // update  RAGProcess status and quickRAGContent for SSE endpoint

      await ragProcessManager.updateQuickRAGContent(
        c.env.currentRAGProcessId,
        quickRAGReply,
        c
      );

      const currentStatus = RAGProcessStatus.PENDING;

      await ragProcessManager.updateRAGProcess(
        c.env.currentRAGProcessId,
        currentStatus,
        c
      );

      return newRAGResult;
    } catch (error) {
      console.error(`Error in quickRAGService.fullQuickRAGProcess: ${error}`);
      throw error;
    }

  },

  async fullQuickRAGProcess(queryID: string, c: Context, query: Query) {
    console.log(`start fullQuickRAGProcess`);
    try {
      const newSearchResult = await this.updateBatchRawDataAndLinks(queryID, c);

      const quickRAGReply = await this.fetchQuickRAG(query, newSearchResult, c);

      console.log(`quickRAGReply: ${quickRAGReply}`);

      console.log(`updated RAGProcess status to PENDING`);

      const newRAGResult = await D1services.createRAGresult(
        queryID,
        quickRAGReply,
        c
      );

      console.log(`created new RAGResult`);
      // update  RAGProcess status and quickRAGContent for SSE endpoint

      await ragProcessManager.updateQuickRAGContent(
        c.env.currentRAGProcessId,
        quickRAGReply,
        c
      );

      const currentStatus = RAGProcessStatus.PENDING;

      await ragProcessManager.updateRAGProcess(
        c.env.currentRAGProcessId,
        currentStatus,
        c
      );

      return newRAGResult;
    } catch (error) {
      console.error(`Error in quickRAGService.fullQuickRAGProcess: ${error}`);
      throw error;
    }
  }
}; 我在想为什么会出现这个情况，是不是DeepRAG没运行完，worker就结束了，还是说SSE就关闭了。要解决的话是不是需要调整架构，把DeepRAG移到duranble object里面，然后再另外写一个SSE 端点？